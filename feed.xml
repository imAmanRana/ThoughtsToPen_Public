<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://thoughtstopen.com/feed.xml" rel="self" type="application/atom+xml"/><link href="https://thoughtstopen.com/" rel="alternate" type="text/html"/><updated>2026-01-08T23:03:39-07:00</updated><id>https://thoughtstopen.com/feed.xml</id><title type="html">Thoughts To Pen</title><subtitle>My thoughts on Computer Programming || Psychology || Personal Finances || &amp; much more...</subtitle><entry><title type="html">Primitive Types in Patterns (Java 25)</title><link href="https://thoughtstopen.com/java-25-primitive-types-in-patterns/" rel="alternate" type="text/html" title="Primitive Types in Patterns (Java 25)"/><published>2025-09-28T10:45:00-06:00</published><updated>2025-09-28T10:45:00-06:00</updated><id>https://thoughtstopen.com/java-25-primitive-types-in-patterns</id><content type="html" xml:base="https://thoughtstopen.com/java-25-primitive-types-in-patterns/"><![CDATA[<h1 id="primitive-types-in-patterns-instanceof-and-switch-jep-507">Primitive Types in Patterns, instanceof, and switch (JEP 507)</h1><p>Pattern Matching has been revolutionizing Java for the past few versions. We’ve seen it with <code class="language-plaintext highlighter-rouge">instanceof</code>, then <code class="language-plaintext highlighter-rouge">switch</code> expressions, and then Record Patterns.</p><p>But there was always one limitation: it only worked with objects (reference types). You couldn’t use it directly with primitives like <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, or <code class="language-plaintext highlighter-rouge">double</code>.</p><p>Java 25 changes that with <strong>Primitive Types in Patterns</strong> (JEP 507 - Preview).</p><h2 id="why-do-we-need-this">Why do we need this?</h2><p>Previously, if you wanted to switch on different types, you had to worry about whether you were dealing with a boxed type (like <code class="language-plaintext highlighter-rouge">Integer</code>) or a primitive (<code class="language-plaintext highlighter-rouge">int</code>).</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Pre-Java 25</span>
<span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="mi">42</span><span class="o">;</span>

<span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Integer</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// This works because 'obj' is an Integer (boxed)</span>
<span class="o">}</span>

<span class="c1">// But you couldn't do this easily with direct primitives in data processing</span>
</code></pre></div></div><h2 id="how-it-works-in-java-25">How it works in Java 25</h2><p>Now, <code class="language-plaintext highlighter-rouge">instanceof</code> and <code class="language-plaintext highlighter-rouge">switch</code> can handle direct primitive type patterns.</p><h3 id="type-testing-with-instanceof">Type Testing with <code class="language-plaintext highlighter-rouge">instanceof</code></h3><p>You can now check if a value “matches” a primitive type. This is particularly useful when dealing with very large numbers or widened types.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">42</span><span class="o">;</span>

<span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="k">instanceof</span> <span class="kt">byte</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"It fits in a byte: "</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>Wait, <code class="language-plaintext highlighter-rouge">long</code> behaves like a <code class="language-plaintext highlighter-rouge">byte</code>? Yes! In pattern matching, <code class="language-plaintext highlighter-rouge">instanceof</code> for primitives checks if the value <strong>can be represented exactly</strong> by the target type without loss of information. Since <code class="language-plaintext highlighter-rouge">42</code> fits in a byte, it matches. If <code class="language-plaintext highlighter-rouge">v</code> was <code class="language-plaintext highlighter-rouge">1000</code>, it would not match <code class="language-plaintext highlighter-rouge">byte b</code>.</p><h3 id="switch-with-primitives">Switch with Primitives</h3><p>The real power shines in <code class="language-plaintext highlighter-rouge">switch</code> expressions. You can now mix and match primitives and objects (if applicable) or simply switch on types for validation.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"One"</span><span class="o">);</span>
        <span class="k">case</span> <span class="kt">byte</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Small number: "</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span>
        <span class="k">case</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Medium number: "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
        <span class="k">default</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Huge number"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>If you call <code class="language-plaintext highlighter-rouge">process(100)</code>, it matches <code class="language-plaintext highlighter-rouge">case byte b</code>. If you call <code class="language-plaintext highlighter-rouge">process(100000)</code>, it matches <code class="language-plaintext highlighter-rouge">case int i</code>.</p><h2 id="unified-type-system">Unified Type System</h2><p>This feature is a huge step towards unifying primitives and objects in Java. It allows we to write more generic data processing logic without constantly boxing and unboxing values or writing cumbersome range checks (e.g., <code class="language-plaintext highlighter-rouge">if (v &gt;= Byte.MIN_VALUE &amp;&amp; v &lt;= Byte.MAX_VALUE)</code>).</p><p><strong>Note:</strong> This is a <strong>Preview</strong> feature in Java 25, so you’ll need to enable preview flags to use it!</p>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java25"/><summary type="html"><![CDATA[Java 25 extends pattern matching to primitive types like int and long, unifying the type system.]]></summary></entry><entry><title type="html">Module Import Declarations (Java 25)</title><link href="https://thoughtstopen.com/java-25-module-import-declarations/" rel="alternate" type="text/html" title="Module Import Declarations (Java 25)"/><published>2025-09-26T10:30:00-06:00</published><updated>2025-09-26T10:30:00-06:00</updated><id>https://thoughtstopen.com/java-25-module-import-declarations</id><content type="html" xml:base="https://thoughtstopen.com/java-25-module-import-declarations/"><![CDATA[<h1 id="module-import-declarations-jep-511">Module Import Declarations (JEP 511)</h1><p>How many lines of your Java files are just <code class="language-plaintext highlighter-rouge">import</code> statements? 10? 20? 50?</p><p>We’ve all been there:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.Collectors</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.Stream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>
<span class="c1">// ... and on and on</span>
</code></pre></div></div><p>Wildcard imports (<code class="language-plaintext highlighter-rouge">import java.util.*</code>) help, but they are limited to a single package. If you use classes from <code class="language-plaintext highlighter-rouge">java.util</code>, <code class="language-plaintext highlighter-rouge">java.io</code>, and <code class="language-plaintext highlighter-rouge">java.net</code>, you still need multiple lines.</p><p>Java 25 introduces <strong>Module Import Declarations</strong> (JEP 511), a powerful way to import <em>everything</em> a module exports with a single line.</p><h2 id="the-power-of-import-module">The Power of <code class="language-plaintext highlighter-rouge">import module</code></h2><p>With this new feature, you can import all the public classes and interfaces from an entire module.</p><p>For example, to access everything in the core Java libraries (the <code class="language-plaintext highlighter-rouge">java.base</code> module), you can write:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ModuleImportExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">);</span> <span class="c1">// from java.util</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"test.txt"</span><span class="o">);</span>           <span class="c1">// from java.io</span>
        <span class="nc">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">();</span>               <span class="c1">// from java.net</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Wait, where are the imports for <code class="language-plaintext highlighter-rouge">List</code>, <code class="language-plaintext highlighter-rouge">File</code>, and <code class="language-plaintext highlighter-rouge">Socket</code>? They are all brought in by <code class="language-plaintext highlighter-rouge">import module java.base;</code>!</p><p>Since <code class="language-plaintext highlighter-rouge">java.base</code> contains packages like <code class="language-plaintext highlighter-rouge">java.lang</code>, <code class="language-plaintext highlighter-rouge">java.io</code>, <code class="language-plaintext highlighter-rouge">java.net</code>, <code class="language-plaintext highlighter-rouge">java.util</code>, and more, importing the module makes all of their public types available to your code.</p><h2 id="handling-naming-conflicts">Handling naming conflicts</h2><p>Since you are importing so many classes, what if there is a conflict? For example, <code class="language-plaintext highlighter-rouge">java.util.Date</code> and <code class="language-plaintext highlighter-rouge">java.sql.Date</code> (if you imported <code class="language-plaintext highlighter-rouge">java.sql</code>).</p><p>Java handles this gracefully. If you use a class name that is ambiguous (exists in multiple imported packages), the compiler will give an error, and you simply need to <strong>explicitly import</strong> the specific class you want to resolve the ambiguity:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">sql</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.sql.Date</span><span class="o">;</span> <span class="c1">// Resolve conflict for 'Date'</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">conflicts</span> <span class="o">{</span>
    <span class="nc">Date</span> <span class="n">sqlDate</span><span class="o">;</span> <span class="c1">// Uses java.sql.Date</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="why-use-this">Why use this?</h2><ol><li><strong>Simplicity</strong>: Especially for learning and prototyping, it removes the friction of hunting down packages.</li><li><strong>Readability</strong>: Reduces visual noise at the top of your files.</li><li><strong>Convenience</strong>: Great for “Java playgrounds” or scripts (especially when combined with <strong>Compact Source Files</strong>!).</li></ol><p>This feature essentially brings the convenience of “import everything” that other languages enjoy, while keeping Java’s strong module system structure.</p>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java25"/><summary type="html"><![CDATA[Say goodbye to import clutter with Module Import Declarations in Java 25.]]></summary></entry><entry><title type="html">Flexible Constructor Bodies (Java 25)</title><link href="https://thoughtstopen.com/java-25-flexible-constructor-bodies/" rel="alternate" type="text/html" title="Flexible Constructor Bodies (Java 25)"/><published>2025-09-24T10:15:00-06:00</published><updated>2025-09-24T10:15:00-06:00</updated><id>https://thoughtstopen.com/java-25-flexible-constructor-bodies</id><content type="html" xml:base="https://thoughtstopen.com/java-25-flexible-constructor-bodies/"><![CDATA[<h1 id="flexible-constructor-bodies-jep-513">Flexible Constructor Bodies (JEP 513)</h1><p>For decades, Java developers have lived by a strict rule: <strong><code class="language-plaintext highlighter-rouge">super()</code> or <code class="language-plaintext highlighter-rouge">this()</code> must be the very first statement in a constructor.</strong></p><p>This restriction often led to awkward workarounds when we needed to validate arguments or prepare data <em>before</em> invoking the parent class constructor. Java 25 solves this with <strong>Flexible Constructor Bodies</strong> (JEP 513).</p><h2 id="the-problem">The Problem</h2><p>Suppose you want to valid an argument before passing it to the superclass constructor. In older Java versions, you couldn’t simply do this:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PositiveBigInteger</span> <span class="kd">extends</span> <span class="nc">BigInteger</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">PositiveBigInteger</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"non-positive value"</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">value</span><span class="o">));</span> <span class="c1">// ERROR in older Java!</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Because the validation check happens before <code class="language-plaintext highlighter-rouge">super()</code>, this code would fail to compile. We often had to resort to static helper methods:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PositiveBigInteger</span> <span class="kd">extends</span> <span class="nc">BigInteger</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">PositiveBigInteger</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">validate</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">validate</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"non-positive value"</span><span class="o">);</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>This works, but it’s verbose and less readable.</p><h2 id="the-java-25-solution">The Java 25 Solution</h2><p>With <strong>Flexible Constructor Bodies</strong>, JDK 25 relaxes this rule. You can now place statements <em>before</em><code class="language-plaintext highlighter-rouge">super()</code> or <code class="language-plaintext highlighter-rouge">this()</code>, as long as they don’t access the instance being created (i.e., you can’t use <code class="language-plaintext highlighter-rouge">this</code> to access fields or methods yet).</p><p>Now, the first example is valid Java code!</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PositiveBigInteger</span> <span class="kd">extends</span> <span class="nc">BigInteger</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">PositiveBigInteger</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"non-positive value"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Validating value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">value</span><span class="o">));</span> <span class="c1">// Perfectly legal in Java 25</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="key-rules">Key Rules</h3><ol><li><strong>No instance access</strong>: You cannot access <code class="language-plaintext highlighter-rouge">this</code> (fields, instance methods) before the <code class="language-plaintext highlighter-rouge">super()</code> call completes. The object is not initialized yet.</li><li><strong>Assignments allowed</strong>: You can assign to local variables.</li><li><strong>Exception throwing</strong>: You can throw exceptions (fail fast!).</li></ol><h2 id="why-is-this-better">Why is this better?</h2><ul><li><strong>Readability</strong>: Validation logic stays inside the constructor where it belongs.</li><li><strong>Safety</strong>: Failing fast before the super constructor (which might be expensive) prevents unnecessary work.</li><li><strong>Cleanliness</strong>: Eliminates the need for artificial static helper methods just to satisfy compiler rules.</li></ul><p>This small change makes writing robust constructors much more natural and intuitive.</p>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java25"/><summary type="html"><![CDATA[Flexible Constructor Bodies in Java 25 allow statements before super(), giving you more control over object initialization.]]></summary></entry><entry><title type="html">Compact Source Files (Java 25)</title><link href="https://thoughtstopen.com/java-25-compact-source-files/" rel="alternate" type="text/html" title="Compact Source Files (Java 25)"/><published>2025-09-22T10:00:00-06:00</published><updated>2025-09-22T10:00:00-06:00</updated><id>https://thoughtstopen.com/java-25-compact-source-files</id><content type="html" xml:base="https://thoughtstopen.com/java-25-compact-source-files/"><![CDATA[<h1 id="compact-source-files--instance-main-methods-jep-512">Compact Source Files &amp; Instance Main Methods (JEP 512)</h1><p><strong>NOTE</strong>: This feature, formerly known as <em>Implicitly Declared Classes and Instance Main Methods</em>, is finalized in Java 25.</p><p>One of the biggest hurdles for beginners learning Java has always been the boilerplate code. To write a simple “Hello, World!”, you needed a public class, a static main method, and an array of Strings argument that you probably wouldn’t use.</p><p>Java 25 changes this with <strong>Compact Source Files</strong> (JEP 512). This feature allows you to write Java programs that are more concise and script-like, without sacrificing the power of the language.</p><h2 id="the-old-way">The Old Way</h2><p>Remember this?</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>For a newcomer, this is a lot to digest. What is <code class="language-plaintext highlighter-rouge">public</code>? What is <code class="language-plaintext highlighter-rouge">static</code>? Why <code class="language-plaintext highlighter-rouge">String[] args</code>?</p><h2 id="the-new-way-java-25">The New Way (Java 25)</h2><p>With Java 25, you can simply write:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>That’s it! No class declaration, no <code class="language-plaintext highlighter-rouge">public</code>, no <code class="language-plaintext highlighter-rouge">static</code>, and no <code class="language-plaintext highlighter-rouge">String[] args</code> if you don’t need them.</p><h3 id="how-it-works">How it works</h3><p>Behind the scenes, the Java compiler treats this as if it were inside an <em>implicitly declared class</em>.</p><ul><li><strong>Instance Main Methods</strong>: The <code class="language-plaintext highlighter-rouge">main</code> method no longer needs to be <code class="language-plaintext highlighter-rouge">static</code>. It can be an instance method.</li><li><strong>No Access Modifiers</strong>: You don’t strict need <code class="language-plaintext highlighter-rouge">public</code> or <code class="language-plaintext highlighter-rouge">protected</code>.</li><li><strong>Implicit Class</strong>: If your source file doesn’t have an outer class declaration, the compiler automatically wraps your methods and fields in a class.</li></ul><h2 id="fields-and-methods">Fields and Methods</h2><p>You can also define fields and other methods just like you would in a normal class:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">"Hello, Java 25!"</span><span class="o">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">greeting</span><span class="o">);</span>
    <span class="n">greetUser</span><span class="o">(</span><span class="s">"Developer"</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">greetUser</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Welcome, "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>This makes Java feel much more like a scripting language for small programs, while still being full-fledged Java.</p><h2 id="why-is-this-important">Why is this important?</h2><ol><li><strong>Beginner Friendly</strong>: Reduces concepts needed to write the first program.</li><li><strong>Less Boilerplate</strong>: clearer code for small utilities and scripts.</li><li><strong>Gradual Complexity</strong>: You can start with a simple method and evolve it into a full class structure as your program grows.</li></ol><p>This feature was previewed in JDK 21 and is now a standard feature in JDK 25!</p>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java25"/><summary type="html"><![CDATA[Java 25 introduces Compact Source Files to reduce boilerplate and make the language more beginner-friendly.]]></summary></entry><entry><title type="html">Java 25 Features</title><link href="https://thoughtstopen.com/java-25-features/" rel="alternate" type="text/html" title="Java 25 Features"/><published>2025-09-20T11:00:00-06:00</published><updated>2025-09-20T11:00:00-06:00</updated><id>https://thoughtstopen.com/java-25-features</id><content type="html" xml:base="https://thoughtstopen.com/java-25-features/"><![CDATA[<h1 id="java-25-release-history">Java 25 Release History</h1><p>Java 25 is a <strong>Long-Term Support (LTS)</strong> release that reached General Availability on <strong>September 16, 2025</strong>.</p><p>As an LTS version, it is designed for stability and long-term enterprise use. Oracle provides <strong>Premier Support</strong> until <strong>September 2030</strong>, with <strong>Extended Support</strong> continuing until <strong>September 2033</strong>. This makes it the recommended version for new production deployments.</p><p>Below are the key features introduced in this release:</p><ul><li><h2 id="compact-source-files-java-25"><a href="/java-25-compact-source-files/">Compact Source Files (Java 25)</a></h2><p>Formerly known as <em>Implicitly Declared Classes</em>, this feature simplifies the structure of Java programs. It removes the need for explicit class declarations and static main methods for small programs.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, Java 25!"</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div></div></li><li><h2 id="flexible-constructor-bodies"><a href="/java-25-flexible-constructor-bodies/">Flexible Constructor Bodies</a></h2><p>This feature relaxes the rule that <code class="language-plaintext highlighter-rouge">super()</code> must be the first statement in a constructor. You can now execute logic (like validation) <em>before</em> calling the parent constructor, provided you don’t access the instance under construction.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="nf">PositiveBigInteger</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"non-positive value"</span><span class="o">);</span>
      <span class="kd">super</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>
  <span class="o">}</span>
</code></pre></div></div></li><li><h2 id="module-import-declarations"><a href="/java-25-module-import-declarations/">Module Import Declarations</a></h2><p>Allows importing all packages exported by a module with a single statement. This significantly reduces the number of import statements needed in a file.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">;</span>

  <span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span> <span class="c1">// from java.util</span>
      <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"test.txt"</span><span class="o">);</span>      <span class="c1">// from java.io</span>
  <span class="o">}</span>
</code></pre></div></div></li><li><h2 id="primitive-types-in-patterns-preview"><a href="/java-25-primitive-types-in-patterns/">Primitive Types in Patterns (Preview)</a></h2><p>Extends pattern matching to support primitive types in <code class="language-plaintext highlighter-rouge">switch</code> and <code class="language-plaintext highlighter-rouge">instanceof</code>. This removes the limitation of only being able to use reference types in patterns.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">switch</span> <span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">case</span> <span class="kt">byte</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Small number: "</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span>
      <span class="k">case</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Medium number: "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div></div></li></ul>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java25"/><summary type="html"><![CDATA[A comprehensive overview of the new features in Java 25, including Compact Source Files, Flexible Constructors, and Primitive Patterns.]]></summary></entry><entry><title type="html">Unnamed Patterns &amp;amp; Variables (Java 21)</title><link href="https://thoughtstopen.com/java-21-unnamed-patterns/" rel="alternate" type="text/html" title="Unnamed Patterns &amp;amp; Variables (Java 21)"/><published>2023-10-29T20:30:00-06:00</published><updated>2023-10-29T20:30:00-06:00</updated><id>https://thoughtstopen.com/java-21-unnamed-patterns</id><content type="html" xml:base="https://thoughtstopen.com/java-21-unnamed-patterns/"><![CDATA[<h1 id="unnamed-patterns--variables">Unnamed Patterns &amp; Variables</h1><p><strong>Unnamed Patterns and Variables</strong> (JEP 443) is a Preview feature in Java 21 that introduces the <strong>underscore (<code class="language-plaintext highlighter-rouge">_</code>)</strong> as a way to say “I don’t care about this value.”</p><h2 id="the-problem-unused-variables">The Problem: Unused Variables</h2><p>Have you ever written a loop or a catch block where you had to declare a variable you never intended to use?</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NumberFormatException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 'e' is unused</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Invalid number"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>Or when iterating:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="nc">Order</span> <span class="n">order</span> <span class="o">:</span> <span class="n">orders</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">total</span><span class="o">++;</span> <span class="c1">// 'order' is unused</span>
<span class="o">}</span>
</code></pre></div></div><p>These unused variables clutter the code and can sometimes trigger compiler warnings or static analysis violations.</p><h2 id="the-solution-the-underscore-_">The Solution: The Underscore <code class="language-plaintext highlighter-rouge">_</code></h2><p>In Java 21, you can replace these with <code class="language-plaintext highlighter-rouge">_</code>. This clearly signals to the reader (and the compiler): <strong>“This variable exists, but I am ignoring it.”</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NumberFormatException</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Clean!</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Invalid number"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="synergy-with-record-patterns">Synergy with Record Patterns</h2><p>This feature shines when combined with <strong>Record Patterns</strong>. Often, you deconstruct a record but only need one specific field.</p><p>Before, you had to declare variables for <em>everything</em>:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We only want 'x', but we have to declare 'y'</span>
<span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">))</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"X is: "</span> <span class="o">+</span> <span class="n">x</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>Now, you can use an <strong>Unnamed Pattern</strong>:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 'y' is ignored using '_'</span>
<span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">))</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"X is: "</span> <span class="o">+</span> <span class="n">x</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>You can even ignore the type type entirely if strict type inference allows it:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">var</span> <span class="n">_</span><span class="o">))</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div><h2 id="summary">Summary</h2><ul><li><strong>Readability</strong>: Reduces visual noise.</li><li><strong>Intent</strong>: Clearly explicitly states that a value is irrelevant.</li><li><strong>Safety</strong>: Impossible to accidentally use a variable you meant to ignore.</li></ul>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[Discover how Unnamed Patterns (_) in Java 21 help you write cleaner code by ignoring unused variables.]]></summary></entry><entry><title type="html">Structured Concurrency (Java 21)</title><link href="https://thoughtstopen.com/java-21-structured-concurrency/" rel="alternate" type="text/html" title="Structured Concurrency (Java 21)"/><published>2023-10-27T20:30:00-06:00</published><updated>2023-10-27T20:30:00-06:00</updated><id>https://thoughtstopen.com/java-21-structured-concurrency</id><content type="html" xml:base="https://thoughtstopen.com/java-21-structured-concurrency/"><![CDATA[<h1 id="structured-concurrency-in-java-21">Structured Concurrency in Java 21</h1><p><strong>Structured Concurrency</strong> (JEP 453) is a Preview feature in Java 21 that aims to simplify multithreaded programming. It treats multiple tasks running in different threads as a single unit of work.</p><h2 id="the-unstructured-problem">The “Unstructured” Problem</h2><p>Traditionally, when you spawn threads (using <code class="language-plaintext highlighter-rouge">ExecutorService</code>), they run independently.</p><ul><li>If the main thread fails, the sub-threads might keep running (leaking resources).</li><li>If one sub-thread fails, the others don’t know about it and might continue uselessly.</li><li>Debugging is hard because the stack traces are disconnected.</li></ul><p>This “fire and forget” style is unstructured, much like <code class="language-plaintext highlighter-rouge">goto</code> statements were for invalid control flow.</p><h2 id="the-structured-solution">The Structured Solution</h2><p>Structured Concurrency introduces <code class="language-plaintext highlighter-rouge">StructuredTaskScope</code>. It ensures that when a scope exits, all its child threads are finished (either completed or cancelled).</p><h3 id="example-fetching-a-user-and-their-orders">Example: Fetching a User and their Orders</h3><p>Imagine you need to fetch a User and their Orders from a database. These are two independent tasks that can run in parallel.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.StructuredTaskScope</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutionException</span><span class="o">;</span>

<span class="nc">Response</span> <span class="nf">handle</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">ExecutionException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StructuredTaskScope</span><span class="o">.</span><span class="na">ShutdownOnFailure</span><span class="o">())</span> <span class="o">{</span>
        
        <span class="c1">// Fork two parallel tasks</span>
        <span class="kt">var</span> <span class="n">userTask</span>  <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">findUser</span><span class="o">());</span>
        <span class="kt">var</span> <span class="n">orderTask</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">fetchOrders</span><span class="o">());</span>

        <span class="c1">// Wait for BOTH to finish. </span>
        <span class="c1">// If EITHER fails, the other is cancelled automatically.</span>
        <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span> 
        
        <span class="c1">// If we get here, both succeeded (or we throw the exception)</span>
        <span class="n">scope</span><span class="o">.</span><span class="na">throwIfFailed</span><span class="o">();</span>

        <span class="c1">// Combine the results</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Response</span><span class="o">(</span><span class="n">userTask</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="n">orderTask</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="key-benefits">Key Benefits</h2><ol><li><strong>Error Handling</strong>: In the example above, if <code class="language-plaintext highlighter-rouge">findUser()</code> throws an exception, <code class="language-plaintext highlighter-rouge">fetchOrders()</code> is automatically cancelled. You don’t waste resources fetching orders for a user that doesn’t exist.</li><li><strong>Clean Code</strong>: The code reads top-to-bottom, like single-threaded code. The <code class="language-plaintext highlighter-rouge">try-with-resources</code> block guarantees cleanup.</li><li><strong>Observability</strong>: Tools can link the threads together, making thread dumps and stack traces much easier to understand.</li></ol><p>Structured Concurrency is the perfect companion to <strong>Virtual Threads</strong>, allowing you to manage thousands of concurrent tasks with sanity and safety.</p>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[Explore Structured Concurrency in Java 21 for more robust, readable, and maintainable concurrent code.]]></summary></entry><entry><title type="html">Unnamed Classes &amp;amp; Instance Main Methods (Java 21)</title><link href="https://thoughtstopen.com/java-21-unnamed-classes/" rel="alternate" type="text/html" title="Unnamed Classes &amp;amp; Instance Main Methods (Java 21)"/><published>2023-10-25T20:30:00-06:00</published><updated>2023-10-25T20:30:00-06:00</updated><id>https://thoughtstopen.com/java-21-unnamed-classes</id><content type="html" xml:base="https://thoughtstopen.com/java-21-unnamed-classes/"><![CDATA[<h1 id="unnamed-classes-and-instance-main-methods">Unnamed Classes and Instance Main Methods</h1><p><strong>Unnamed Classes and Instance Main Methods</strong> (JEP 445) is a Preview feature introduced in Java 21. While it might sound technical, its goal is very simple: <strong>Make Java easier to learn and write for small programs.</strong></p><h2 id="the-hello-world-barrier">The “Hello World” Barrier</h2><p>For decades, the first thing a student sees when learning Java is this:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>This is a lot of “boilerplate” (clutter). A beginner immediately has questions:</p><ul><li>Why <code class="language-plaintext highlighter-rouge">public</code>?</li><li>What is a <code class="language-plaintext highlighter-rouge">class</code>?</li><li>Why <code class="language-plaintext highlighter-rouge">static</code>?</li><li>What is <code class="language-plaintext highlighter-rouge">void</code>?</li><li>What is <code class="language-plaintext highlighter-rouge">String[] args</code>?</li></ul><p>This complexity makes Java feel heavy for simple scripts or experiments compared to languages like Python or JavaScript.</p><h2 id="the-new-simple-way">The New, Simple Way</h2><p>With Java 21, the language is getting out of your way. You can now write a valid program that looks like this:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>That’s it. No class declaration. No <code class="language-plaintext highlighter-rouge">public</code>. No <code class="language-plaintext highlighter-rouge">static</code>. No <code class="language-plaintext highlighter-rouge">args</code>.</p><h2 id="key-changes">Key Changes</h2><h3 id="1-instance-main-methods">1. Instance Main Methods</h3><p>You no longer strictly need <code class="language-plaintext highlighter-rouge">public static void main(String[] args)</code>.</p><ul><li>It doesn’t need to be <code class="language-plaintext highlighter-rouge">public</code>.</li><li>It doesn’t need to be <code class="language-plaintext highlighter-rouge">static</code>.</li><li>It doesn’t need <code class="language-plaintext highlighter-rouge">String[] args</code> if you aren’t using command-line arguments.</li></ul><p>Java will now look for a <code class="language-plaintext highlighter-rouge">void main()</code> method and launch it.</p><h3 id="2-unnamed-classes">2. Unnamed Classes</h3><p>You noticed the code above didn’t have <code class="language-plaintext highlighter-rouge">class HelloWorld { ... }</code> wrapping it? When you write methods and fields at the top level of a file, Java automatically wraps them in an “unnamed class” for you.</p><p>This allows you to write scripts that focus purely on logic:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Just fields and methods!</span>
<span class="nc">String</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>

<span class="nc">String</span> <span class="nf">getMessage</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">greeting</span> <span class="o">+</span> <span class="s">", World!"</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getMessage</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="gradual-growth">“Gradual” Growth</h2><p>The best part of this feature is that it is compatible with valid Java. As your program grows larger, you can easily wrap it in a class later. You aren’t learning a specific “dialect” of Java; you are just learning the core parts (methods, variables) first, and the organizational parts (classes, packages, access modifiers) later.</p><h2 id="how-to-run-it">How to Run It</h2><p>Since this is a <strong>Preview Feature</strong> in Java 21, you must explicitly enable it.</p><p><strong>Compiling and Running:</strong></p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javac <span class="nt">--release</span> 21 <span class="nt">--enable-preview</span> HelloWorld.java
java <span class="nt">--enable-preview</span> HelloWorld
</code></pre></div></div><p><strong>Running directly (Source-Code Launch):</strong></p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">--enable-preview</span> <span class="nt">--source</span> 21 HelloWorld.java
</code></pre></div></div><p>This feature creates a smooth “on-ramp” for Java, making it accessible for beginners and concise for experts writing quick tools.</p>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[Simplify your Java learning layout with Unnamed Classes and Instance Main Methods in Java 21.]]></summary></entry><entry><title type="html">Pattern Matching for switch (Java 21)</title><link href="https://thoughtstopen.com/java-21-pattern-matching-switch/" rel="alternate" type="text/html" title="Pattern Matching for switch (Java 21)"/><published>2023-10-22T20:30:00-06:00</published><updated>2023-10-22T20:30:00-06:00</updated><id>https://thoughtstopen.com/java-21-pattern-matching-switch</id><content type="html" xml:base="https://thoughtstopen.com/java-21-pattern-matching-switch/"><![CDATA[<h1 id="pattern-matching-for-switch">Pattern Matching for switch</h1><p><strong>Pattern Matching for switch</strong> (JEP 441) is a game-changer feature in Java 21. It fundamentally upgrades the <code class="language-plaintext highlighter-rouge">switch</code> statement, which previously could only test for exact equality against a few types (enums, strings, integers).</p><p>Now, <code class="language-plaintext highlighter-rouge">switch</code> can test against <strong>Types</strong>, meaning it can replace long, complex chains of <code class="language-plaintext highlighter-rouge">if-else</code> statements.</p><h2 id="the-if-else-problem">The “If-Else” Problem</h2><p>Traditionally, when you had an object and needed to perform different actions based on its specific class, you had to write a chain of checks. This pattern is often called “type testing”:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The Old Way: Verbose and repetitive</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">formatter</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Integer</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"int %d"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Long</span> <span class="n">l</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"long %d"</span><span class="o">,</span> <span class="n">l</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Double</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"double %f"</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"String %s"</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>This code is hard to read because the logic (<code class="language-plaintext highlighter-rouge">instanceof</code>) is repeated, and it’s easy to miss a <code class="language-plaintext highlighter-rouge">return</code> or an <code class="language-plaintext highlighter-rouge">else</code>.</p><h2 id="the-switch-solution">The Switch Solution</h2><p>Verify 21 allows us to use <strong>patterns</strong> in <code class="language-plaintext highlighter-rouge">case</code> labels. We can match the type of the object directly in the switch.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The Java 21 Way: Clean and Declarative</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">formatterPatternSwitch</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span> <span class="o">(</span><span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Integer</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"int %d"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">Long</span> <span class="n">l</span>    <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"long %d"</span><span class="o">,</span> <span class="n">l</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">Double</span> <span class="n">d</span>  <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"double %f"</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">String</span> <span class="n">s</span>  <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"String %s"</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
        <span class="k">case</span> <span class="kc">null</span>      <span class="o">-&gt;</span> <span class="s">"null"</span><span class="o">;</span> <span class="c1">// We can now handle null too!</span>
        <span class="k">default</span>        <span class="o">-&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div><p>This isn’t just syntactic sugar—it’s safer. The compiler can now help check if your logic makes sense.</p><h2 id="new-feature-handling-null">New Feature: Handling Null</h2><p>A historical pain point of <code class="language-plaintext highlighter-rouge">switch</code> was that it would throw a <code class="language-plaintext highlighter-rouge">NullPointerException</code> immediately if the variable tested was <code class="language-plaintext highlighter-rouge">null</code>.</p><p>In Java 21, you can write <code class="language-plaintext highlighter-rouge">case null</code>! This allows you to handle the “no value” scenario right alongside your other logic, without needing a separate <code class="language-plaintext highlighter-rouge">if (obj == null)</code> check before the switch.</p><h2 id="refined-patterns-with-when">Refined Patterns with <code class="language-plaintext highlighter-rouge">when</code></h2><p>Sometimes, matching the Type isn’t enough. You might want to match “A String, but only if it has length 1”.</p><p>In the past, you’d have to use a broad <code class="language-plaintext highlighter-rouge">case String s</code> and then put an <code class="language-plaintext highlighter-rouge">if</code> inside it. Now, you can use the <code class="language-plaintext highlighter-rouge">when</code> keyword (called a “guard”) to refine your match.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">testBox</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Matches IF it is a String AND the length is 1</span>
        <span class="k">case</span> <span class="nc">String</span> <span class="n">s</span> <span class="n">when</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Single char string"</span><span class="o">);</span>
        
        <span class="c1">// Matches all other Strings</span>
        <span class="k">case</span> <span class="nc">String</span> <span class="n">s</span>                      <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"String"</span><span class="o">);</span>
        
        <span class="c1">// Fallback for everything else</span>
        <span class="k">default</span>                            <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Other"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="essential-rules">Essential Rules</h2><ol><li><strong>Order Matters</strong>: Java checks cases from top to bottom. You must put more specific cases (like the <code class="language-plaintext highlighter-rouge">String</code> with <code class="language-plaintext highlighter-rouge">when</code> length is 1) before general cases (plain <code class="language-plaintext highlighter-rouge">String</code>). If you don’t, the compiler will warn you that the code is “dominated” (unreachable).</li><li><strong>Completeness</strong>: If you are using a switch <strong>expression</strong> (assigning it to a variable or returning it), you must cover all possible options. Usually, this means you need a <code class="language-plaintext highlighter-rouge">default</code> case to handle “everything else”.</li></ol><p>Pattern Matching for switch brings Java closer to modern functional languages, making code safer, shorter, and more expressive.</p>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[Pattern Matching for switch in Java 21 revolutionizes control flow with type testing and complex case logic.]]></summary></entry><entry><title type="html">Record Patterns (Java 21)</title><link href="https://thoughtstopen.com/java-21-record-patterns/" rel="alternate" type="text/html" title="Record Patterns (Java 21)"/><published>2023-10-20T20:30:00-06:00</published><updated>2023-10-20T20:30:00-06:00</updated><id>https://thoughtstopen.com/java-21-record-patterns</id><content type="html" xml:base="https://thoughtstopen.com/java-21-record-patterns/"><![CDATA[<h1 id="record-patterns-in-java-21">Record Patterns in Java 21</h1><p><strong>Record Patterns</strong> (JEP 440) have officially graduated from preview to a standard feature in Java 21. This feature significantly upgrades how we handle data in Java, specifically when working with <strong>Records</strong>.</p><h2 id="what-is-a-record-pattern">What is a Record Pattern?</h2><p>In simple terms, a <strong>Record Pattern</strong> allows you to “deconstruct” or “unpack” a Record object into its individual components directly.</p><p>Think of it as the opposite of creating an object. When you create a <code class="language-plaintext highlighter-rouge">new Point(10, 20)</code>, you are packing two integers into a <code class="language-plaintext highlighter-rouge">Point</code> object. With Record Patterns, you can unbox those values back into two separate integer variables in a single step.</p><h2 id="the-problem-verbose-data-extraction">The Problem: Verbose Data Extraction</h2><p>Before Java 21, extracting data from an object was a three-step process:</p><ol><li><strong>Check</strong> the type (is this a <code class="language-plaintext highlighter-rouge">Point</code>?).</li><li><strong>Cast</strong> the object to that type (turn <code class="language-plaintext highlighter-rouge">obj</code> into <code class="language-plaintext highlighter-rouge">Point p</code>).</li><li><strong>Access</strong> the fields (call <code class="language-plaintext highlighter-rouge">p.x()</code> and <code class="language-plaintext highlighter-rouge">p.y()</code>).</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{}</span>

<span class="kd">static</span> <span class="kt">void</span> <span class="nf">printSum</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Old Style: Check, Cast, Access</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Point</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">x</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">y</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>This acts as “boilerplate” code—it’s repetitive and adds noise to your logic.</p><h2 id="the-solution-clean-deconstruction">The Solution: Clean Deconstruction</h2><p>With <strong>Record Patterns</strong>, you can combine all three steps into one. When you ask <code class="language-plaintext highlighter-rouge">instanceof Point(int x, int y)</code>, Java does the following for you:</p><ol><li>Checks if <code class="language-plaintext highlighter-rouge">obj</code> is a <code class="language-plaintext highlighter-rouge">Point</code>.</li><li>If it is, it extracts the <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> values.</li><li>It assigns them to new variables <code class="language-plaintext highlighter-rouge">int x</code> and <code class="language-plaintext highlighter-rouge">int y</code> that you can use immediately.</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">printSum</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// New Style: Check &amp; Extract in one line</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>This makes your code much easier to read because it focuses on <em>what</em> you normally do with data—use it!</p><h2 id="powerful-nested-patterns">Powerful Nested Patterns</h2><p>The real power of Record Patterns appears when you have records inside other records. Imagine a <code class="language-plaintext highlighter-rouge">ColoredPoint</code> that contains a <code class="language-plaintext highlighter-rouge">Point</code> and a <code class="language-plaintext highlighter-rouge">Color</code>.</p><p>accessing the ‘x’ coordinate of a colored point used to involve a chain of accessors: <code class="language-plaintext highlighter-rouge">coloredPoint.p().x()</code>.</p><p>Now, you can drill down deep into the structure in one go:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{}</span>
<span class="n">record</span> <span class="nf">ColoredPoint</span><span class="o">(</span><span class="nc">Point</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Color</span> <span class="n">c</span><span class="o">)</span> <span class="o">{}</span>
<span class="kd">enum</span> <span class="nc">Color</span> <span class="o">{</span> <span class="no">RED</span><span class="o">,</span> <span class="no">GREEN</span><span class="o">,</span> <span class="no">BLUE</span> <span class="o">}</span>

<span class="kd">static</span> <span class="kt">void</span> <span class="nf">printColorPoint</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Nested Extraction</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nf">ColoredPoint</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">),</span> <span class="nc">Color</span> <span class="n">c</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// We have direct access to 'x', 'y' and 'c' here!</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Point at ("</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="s">") has color "</span> <span class="o">+</span> <span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>This is called <strong>Composition</strong>. You are composing patterns together to match complex data structures. It makes traversing data trees (like JSON-like structures, ASTs, or geometric shapes) incredibly distinct and declarative.</p><h2 id="summary">Summary</h2><ul><li><strong>Less Boilerplate</strong>: No more casting or calling <code class="language-plaintext highlighter-rouge">.get()</code> or accessor descriptors manually.</li><li><strong>Readable</strong>: The code looks like the data structure it is processing.</li><li><strong>Declarative</strong>: You state what the data should look like, and Java handles the extraction.</li></ul>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[Learn how Record Patterns in Java 21 allow for powerful and concise data navigation and processing.]]></summary></entry></feed>