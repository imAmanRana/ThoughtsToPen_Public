<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://thoughtstopen.com/feed.xml" rel="self" type="application/atom+xml"/><link href="https://thoughtstopen.com/" rel="alternate" type="text/html"/><updated>2026-01-08T21:12:57-07:00</updated><id>https://thoughtstopen.com/feed.xml</id><title type="html">Thoughts To Pen</title><subtitle>My thoughts on Computer Programming || Psychology || Personal Finances || &amp; much more...</subtitle><entry><title type="html">Unnamed Patterns &amp;amp; Variables (Java 21)</title><link href="https://thoughtstopen.com/java-21-unnamed-patterns/" rel="alternate" type="text/html" title="Unnamed Patterns &amp;amp; Variables (Java 21)"/><published>2026-01-05T11:30:00-07:00</published><updated>2026-01-05T11:30:00-07:00</updated><id>https://thoughtstopen.com/java-21-unnamed-patterns</id><content type="html" xml:base="https://thoughtstopen.com/java-21-unnamed-patterns/"><![CDATA[<h1 id="unnamed-patterns--variables">Unnamed Patterns &amp; Variables</h1><p><strong>Unnamed Patterns and Variables</strong> (JEP 443) is a Preview feature in Java 21 that introduces the <strong>underscore (<code class="language-plaintext highlighter-rouge">_</code>)</strong> as a way to say “I don’t care about this value.”</p><h2 id="the-problem-unused-variables">The Problem: Unused Variables</h2><p>Have you ever written a loop or a catch block where you had to declare a variable you never intended to use?</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NumberFormatException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 'e' is unused</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Invalid number"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>Or when iterating:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="nc">Order</span> <span class="n">order</span> <span class="o">:</span> <span class="n">orders</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">total</span><span class="o">++;</span> <span class="c1">// 'order' is unused</span>
<span class="o">}</span>
</code></pre></div></div><p>These unused variables clutter the code and can sometimes trigger compiler warnings or static analysis violations.</p><h2 id="the-solution-the-underscore-_">The Solution: The Underscore <code class="language-plaintext highlighter-rouge">_</code></h2><p>In Java 21, you can replace these with <code class="language-plaintext highlighter-rouge">_</code>. This clearly signals to the reader (and the compiler): <strong>“This variable exists, but I am ignoring it.”</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NumberFormatException</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Clean!</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Invalid number"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="synergy-with-record-patterns">Synergy with Record Patterns</h2><p>This feature shines when combined with <strong>Record Patterns</strong>. Often, you deconstruct a record but only need one specific field.</p><p>Before, you had to declare variables for <em>everything</em>:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We only want 'x', but we have to declare 'y'</span>
<span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">))</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"X is: "</span> <span class="o">+</span> <span class="n">x</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>Now, you can use an <strong>Unnamed Pattern</strong>:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 'y' is ignored using '_'</span>
<span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">))</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"X is: "</span> <span class="o">+</span> <span class="n">x</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>You can even ignore the type type entirely if strict type inference allows it:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">var</span> <span class="n">_</span><span class="o">))</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div><h2 id="summary">Summary</h2><ul><li><strong>Readability</strong>: Reduces visual noise.</li><li><strong>Intent</strong>: Clearly explicitly states that a value is irrelevant.</li><li><strong>Safety</strong>: Impossible to accidentally use a variable you meant to ignore.</li></ul>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[Unnamed Patterns and Variables (Preview) in Java 21]]></summary></entry><entry><title type="html">Structured Concurrency (Java 21)</title><link href="https://thoughtstopen.com/java-21-structured-concurrency/" rel="alternate" type="text/html" title="Structured Concurrency (Java 21)"/><published>2026-01-05T11:00:00-07:00</published><updated>2026-01-05T11:00:00-07:00</updated><id>https://thoughtstopen.com/java-21-structured-concurrency</id><content type="html" xml:base="https://thoughtstopen.com/java-21-structured-concurrency/"><![CDATA[<h1 id="structured-concurrency-in-java-21">Structured Concurrency in Java 21</h1><p><strong>Structured Concurrency</strong> (JEP 453) is a Preview feature in Java 21 that aims to simplify multithreaded programming. It treats multiple tasks running in different threads as a single unit of work.</p><h2 id="the-unstructured-problem">The “Unstructured” Problem</h2><p>Traditionally, when you spawn threads (using <code class="language-plaintext highlighter-rouge">ExecutorService</code>), they run independently.</p><ul><li>If the main thread fails, the sub-threads might keep running (leaking resources).</li><li>If one sub-thread fails, the others don’t know about it and might continue uselessly.</li><li>Debugging is hard because the stack traces are disconnected.</li></ul><p>This “fire and forget” style is unstructured, much like <code class="language-plaintext highlighter-rouge">goto</code> statements were for invalid control flow.</p><h2 id="the-structured-solution">The Structured Solution</h2><p>Structured Concurrency introduces <code class="language-plaintext highlighter-rouge">StructuredTaskScope</code>. It ensures that when a scope exits, all its child threads are finished (either completed or cancelled).</p><h3 id="example-fetching-a-user-and-their-orders">Example: Fetching a User and their Orders</h3><p>Imagine you need to fetch a User and their Orders from a database. These are two independent tasks that can run in parallel.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.StructuredTaskScope</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutionException</span><span class="o">;</span>

<span class="nc">Response</span> <span class="nf">handle</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">ExecutionException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StructuredTaskScope</span><span class="o">.</span><span class="na">ShutdownOnFailure</span><span class="o">())</span> <span class="o">{</span>
        
        <span class="c1">// Fork two parallel tasks</span>
        <span class="kt">var</span> <span class="n">userTask</span>  <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">findUser</span><span class="o">());</span>
        <span class="kt">var</span> <span class="n">orderTask</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">fetchOrders</span><span class="o">());</span>

        <span class="c1">// Wait for BOTH to finish. </span>
        <span class="c1">// If EITHER fails, the other is cancelled automatically.</span>
        <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span> 
        
        <span class="c1">// If we get here, both succeeded (or we throw the exception)</span>
        <span class="n">scope</span><span class="o">.</span><span class="na">throwIfFailed</span><span class="o">();</span>

        <span class="c1">// Combine the results</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Response</span><span class="o">(</span><span class="n">userTask</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="n">orderTask</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="key-benefits">Key Benefits</h2><ol><li><strong>Error Handling</strong>: In the example above, if <code class="language-plaintext highlighter-rouge">findUser()</code> throws an exception, <code class="language-plaintext highlighter-rouge">fetchOrders()</code> is automatically cancelled. You don’t waste resources fetching orders for a user that doesn’t exist.</li><li><strong>Clean Code</strong>: The code reads top-to-bottom, like single-threaded code. The <code class="language-plaintext highlighter-rouge">try-with-resources</code> block guarantees cleanup.</li><li><strong>Observability</strong>: Tools can link the threads together, making thread dumps and stack traces much easier to understand.</li></ol><p>Structured Concurrency is the perfect companion to <strong>Virtual Threads</strong>, allowing you to manage thousands of concurrent tasks with sanity and safety.</p>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[Structured Concurrency (Preview) in Java 21]]></summary></entry><entry><title type="html">Unnamed Classes &amp;amp; Instance Main Methods (Java 21)</title><link href="https://thoughtstopen.com/java-21-unnamed-classes/" rel="alternate" type="text/html" title="Unnamed Classes &amp;amp; Instance Main Methods (Java 21)"/><published>2026-01-05T10:00:00-07:00</published><updated>2026-01-05T10:00:00-07:00</updated><id>https://thoughtstopen.com/java-21-unnamed-classes</id><content type="html" xml:base="https://thoughtstopen.com/java-21-unnamed-classes/"><![CDATA[<h1 id="unnamed-classes-and-instance-main-methods">Unnamed Classes and Instance Main Methods</h1><p><strong>Unnamed Classes and Instance Main Methods</strong> (JEP 445) is a Preview feature introduced in Java 21. While it might sound technical, its goal is very simple: <strong>Make Java easier to learn and write for small programs.</strong></p><h2 id="the-hello-world-barrier">The “Hello World” Barrier</h2><p>For decades, the first thing a student sees when learning Java is this:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>This is a lot of “boilerplate” (clutter). A beginner immediately has questions:</p><ul><li>Why <code class="language-plaintext highlighter-rouge">public</code>?</li><li>What is a <code class="language-plaintext highlighter-rouge">class</code>?</li><li>Why <code class="language-plaintext highlighter-rouge">static</code>?</li><li>What is <code class="language-plaintext highlighter-rouge">void</code>?</li><li>What is <code class="language-plaintext highlighter-rouge">String[] args</code>?</li></ul><p>This complexity makes Java feel heavy for simple scripts or experiments compared to languages like Python or JavaScript.</p><h2 id="the-new-simple-way">The New, Simple Way</h2><p>With Java 21, the language is getting out of your way. You can now write a valid program that looks like this:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>That’s it. No class declaration. No <code class="language-plaintext highlighter-rouge">public</code>. No <code class="language-plaintext highlighter-rouge">static</code>. No <code class="language-plaintext highlighter-rouge">args</code>.</p><h2 id="key-changes">Key Changes</h2><h3 id="1-instance-main-methods">1. Instance Main Methods</h3><p>You no longer strictly need <code class="language-plaintext highlighter-rouge">public static void main(String[] args)</code>.</p><ul><li>It doesn’t need to be <code class="language-plaintext highlighter-rouge">public</code>.</li><li>It doesn’t need to be <code class="language-plaintext highlighter-rouge">static</code>.</li><li>It doesn’t need <code class="language-plaintext highlighter-rouge">String[] args</code> if you aren’t using command-line arguments.</li></ul><p>Java will now look for a <code class="language-plaintext highlighter-rouge">void main()</code> method and launch it.</p><h3 id="2-unnamed-classes">2. Unnamed Classes</h3><p>You noticed the code above didn’t have <code class="language-plaintext highlighter-rouge">class HelloWorld { ... }</code> wrapping it? When you write methods and fields at the top level of a file, Java automatically wraps them in an “unnamed class” for you.</p><p>This allows you to write scripts that focus purely on logic:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Just fields and methods!</span>
<span class="nc">String</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>

<span class="nc">String</span> <span class="nf">getMessage</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">greeting</span> <span class="o">+</span> <span class="s">", World!"</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getMessage</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="gradual-growth">“Gradual” Growth</h2><p>The best part of this feature is that it is compatible with valid Java. As your program grows larger, you can easily wrap it in a class later. You aren’t learning a specific “dialect” of Java; you are just learning the core parts (methods, variables) first, and the organizational parts (classes, packages, access modifiers) later.</p><h2 id="how-to-run-it">How to Run It</h2><p>Since this is a <strong>Preview Feature</strong> in Java 21, you must explicitly enable it.</p><p><strong>Compiling and Running:</strong></p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javac <span class="nt">--release</span> 21 <span class="nt">--enable-preview</span> HelloWorld.java
java <span class="nt">--enable-preview</span> HelloWorld
</code></pre></div></div><p><strong>Running directly (Source-Code Launch):</strong></p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">--enable-preview</span> <span class="nt">--source</span> 21 HelloWorld.java
</code></pre></div></div><p>This feature creates a smooth “on-ramp” for Java, making it accessible for beginners and concise for experts writing quick tools.</p>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[Unnamed Classes and Instance Main Methods (Preview) in Java 21]]></summary></entry><entry><title type="html">Pattern Matching for switch (Java 21)</title><link href="https://thoughtstopen.com/java-21-pattern-matching-switch/" rel="alternate" type="text/html" title="Pattern Matching for switch (Java 21)"/><published>2026-01-05T09:30:00-07:00</published><updated>2026-01-05T09:30:00-07:00</updated><id>https://thoughtstopen.com/java-21-pattern-matching-switch</id><content type="html" xml:base="https://thoughtstopen.com/java-21-pattern-matching-switch/"><![CDATA[<h1 id="pattern-matching-for-switch">Pattern Matching for switch</h1><p><strong>Pattern Matching for switch</strong> (JEP 441) is a game-changer feature in Java 21. It fundamentally upgrades the <code class="language-plaintext highlighter-rouge">switch</code> statement, which previously could only test for exact equality against a few types (enums, strings, integers).</p><p>Now, <code class="language-plaintext highlighter-rouge">switch</code> can test against <strong>Types</strong>, meaning it can replace long, complex chains of <code class="language-plaintext highlighter-rouge">if-else</code> statements.</p><h2 id="the-if-else-problem">The “If-Else” Problem</h2><p>Traditionally, when you had an object and needed to perform different actions based on its specific class, you had to write a chain of checks. This pattern is often called “type testing”:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The Old Way: Verbose and repetitive</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">formatter</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Integer</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"int %d"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Long</span> <span class="n">l</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"long %d"</span><span class="o">,</span> <span class="n">l</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Double</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"double %f"</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"String %s"</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>This code is hard to read because the logic (<code class="language-plaintext highlighter-rouge">instanceof</code>) is repeated, and it’s easy to miss a <code class="language-plaintext highlighter-rouge">return</code> or an <code class="language-plaintext highlighter-rouge">else</code>.</p><h2 id="the-switch-solution">The Switch Solution</h2><p>Verify 21 allows us to use <strong>patterns</strong> in <code class="language-plaintext highlighter-rouge">case</code> labels. We can match the type of the object directly in the switch.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The Java 21 Way: Clean and Declarative</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">formatterPatternSwitch</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span> <span class="o">(</span><span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Integer</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"int %d"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">Long</span> <span class="n">l</span>    <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"long %d"</span><span class="o">,</span> <span class="n">l</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">Double</span> <span class="n">d</span>  <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"double %f"</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">String</span> <span class="n">s</span>  <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"String %s"</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
        <span class="k">case</span> <span class="kc">null</span>      <span class="o">-&gt;</span> <span class="s">"null"</span><span class="o">;</span> <span class="c1">// We can now handle null too!</span>
        <span class="k">default</span>        <span class="o">-&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div><p>This isn’t just syntactic sugar—it’s safer. The compiler can now help check if your logic makes sense.</p><h2 id="new-feature-handling-null">New Feature: Handling Null</h2><p>A historical pain point of <code class="language-plaintext highlighter-rouge">switch</code> was that it would throw a <code class="language-plaintext highlighter-rouge">NullPointerException</code> immediately if the variable tested was <code class="language-plaintext highlighter-rouge">null</code>.</p><p>In Java 21, you can write <code class="language-plaintext highlighter-rouge">case null</code>! This allows you to handle the “no value” scenario right alongside your other logic, without needing a separate <code class="language-plaintext highlighter-rouge">if (obj == null)</code> check before the switch.</p><h2 id="refined-patterns-with-when">Refined Patterns with <code class="language-plaintext highlighter-rouge">when</code></h2><p>Sometimes, matching the Type isn’t enough. You might want to match “A String, but only if it has length 1”.</p><p>In the past, you’d have to use a broad <code class="language-plaintext highlighter-rouge">case String s</code> and then put an <code class="language-plaintext highlighter-rouge">if</code> inside it. Now, you can use the <code class="language-plaintext highlighter-rouge">when</code> keyword (called a “guard”) to refine your match.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">testBox</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Matches IF it is a String AND the length is 1</span>
        <span class="k">case</span> <span class="nc">String</span> <span class="n">s</span> <span class="n">when</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Single char string"</span><span class="o">);</span>
        
        <span class="c1">// Matches all other Strings</span>
        <span class="k">case</span> <span class="nc">String</span> <span class="n">s</span>                      <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"String"</span><span class="o">);</span>
        
        <span class="c1">// Fallback for everything else</span>
        <span class="k">default</span>                            <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Other"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="essential-rules">Essential Rules</h2><ol><li><strong>Order Matters</strong>: Java checks cases from top to bottom. You must put more specific cases (like the <code class="language-plaintext highlighter-rouge">String</code> with <code class="language-plaintext highlighter-rouge">when</code> length is 1) before general cases (plain <code class="language-plaintext highlighter-rouge">String</code>). If you don’t, the compiler will warn you that the code is “dominated” (unreachable).</li><li><strong>Completeness</strong>: If you are using a switch <strong>expression</strong> (assigning it to a variable or returning it), you must cover all possible options. Usually, this means you need a <code class="language-plaintext highlighter-rouge">default</code> case to handle “everything else”.</li></ol><p>Pattern Matching for switch brings Java closer to modern functional languages, making code safer, shorter, and more expressive.</p>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[Pattern Matching for switch introduced in Java 21]]></summary></entry><entry><title type="html">Record Patterns (Java 21)</title><link href="https://thoughtstopen.com/java-21-record-patterns/" rel="alternate" type="text/html" title="Record Patterns (Java 21)"/><published>2026-01-05T09:00:00-07:00</published><updated>2026-01-05T09:00:00-07:00</updated><id>https://thoughtstopen.com/java-21-record-patterns</id><content type="html" xml:base="https://thoughtstopen.com/java-21-record-patterns/"><![CDATA[<h1 id="record-patterns-in-java-21">Record Patterns in Java 21</h1><p><strong>Record Patterns</strong> (JEP 440) have officially graduated from preview to a standard feature in Java 21. This feature significantly upgrades how we handle data in Java, specifically when working with <strong>Records</strong>.</p><h2 id="what-is-a-record-pattern">What is a Record Pattern?</h2><p>In simple terms, a <strong>Record Pattern</strong> allows you to “deconstruct” or “unpack” a Record object into its individual components directly.</p><p>Think of it as the opposite of creating an object. When you create a <code class="language-plaintext highlighter-rouge">new Point(10, 20)</code>, you are packing two integers into a <code class="language-plaintext highlighter-rouge">Point</code> object. With Record Patterns, you can unbox those values back into two separate integer variables in a single step.</p><h2 id="the-problem-verbose-data-extraction">The Problem: Verbose Data Extraction</h2><p>Before Java 21, extracting data from an object was a three-step process:</p><ol><li><strong>Check</strong> the type (is this a <code class="language-plaintext highlighter-rouge">Point</code>?).</li><li><strong>Cast</strong> the object to that type (turn <code class="language-plaintext highlighter-rouge">obj</code> into <code class="language-plaintext highlighter-rouge">Point p</code>).</li><li><strong>Access</strong> the fields (call <code class="language-plaintext highlighter-rouge">p.x()</code> and <code class="language-plaintext highlighter-rouge">p.y()</code>).</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{}</span>

<span class="kd">static</span> <span class="kt">void</span> <span class="nf">printSum</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Old Style: Check, Cast, Access</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Point</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">x</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">y</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>This acts as “boilerplate” code—it’s repetitive and adds noise to your logic.</p><h2 id="the-solution-clean-deconstruction">The Solution: Clean Deconstruction</h2><p>With <strong>Record Patterns</strong>, you can combine all three steps into one. When you ask <code class="language-plaintext highlighter-rouge">instanceof Point(int x, int y)</code>, Java does the following for you:</p><ol><li>Checks if <code class="language-plaintext highlighter-rouge">obj</code> is a <code class="language-plaintext highlighter-rouge">Point</code>.</li><li>If it is, it extracts the <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> values.</li><li>It assigns them to new variables <code class="language-plaintext highlighter-rouge">int x</code> and <code class="language-plaintext highlighter-rouge">int y</code> that you can use immediately.</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">printSum</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// New Style: Check &amp; Extract in one line</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>This makes your code much easier to read because it focuses on <em>what</em> you normally do with data—use it!</p><h2 id="powerful-nested-patterns">Powerful Nested Patterns</h2><p>The real power of Record Patterns appears when you have records inside other records. Imagine a <code class="language-plaintext highlighter-rouge">ColoredPoint</code> that contains a <code class="language-plaintext highlighter-rouge">Point</code> and a <code class="language-plaintext highlighter-rouge">Color</code>.</p><p>accessing the ‘x’ coordinate of a colored point used to involve a chain of accessors: <code class="language-plaintext highlighter-rouge">coloredPoint.p().x()</code>.</p><p>Now, you can drill down deep into the structure in one go:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{}</span>
<span class="n">record</span> <span class="nf">ColoredPoint</span><span class="o">(</span><span class="nc">Point</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Color</span> <span class="n">c</span><span class="o">)</span> <span class="o">{}</span>
<span class="kd">enum</span> <span class="nc">Color</span> <span class="o">{</span> <span class="no">RED</span><span class="o">,</span> <span class="no">GREEN</span><span class="o">,</span> <span class="no">BLUE</span> <span class="o">}</span>

<span class="kd">static</span> <span class="kt">void</span> <span class="nf">printColorPoint</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Nested Extraction</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nf">ColoredPoint</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">),</span> <span class="nc">Color</span> <span class="n">c</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// We have direct access to 'x', 'y' and 'c' here!</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Point at ("</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="s">") has color "</span> <span class="o">+</span> <span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>This is called <strong>Composition</strong>. You are composing patterns together to match complex data structures. It makes traversing data trees (like JSON-like structures, ASTs, or geometric shapes) incredibly distinct and declarative.</p><h2 id="summary">Summary</h2><ul><li><strong>Less Boilerplate</strong>: No more casting or calling <code class="language-plaintext highlighter-rouge">.get()</code> or accessor descriptors manually.</li><li><strong>Readable</strong>: The code looks like the data structure it is processing.</li><li><strong>Declarative</strong>: You state what the data should look like, and Java handles the extraction.</li></ul>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[Record Patterns introduced in Java 21]]></summary></entry><entry><title type="html">Sequenced Collections (Java 21)</title><link href="https://thoughtstopen.com/java-21-sequenced-collections/" rel="alternate" type="text/html" title="Sequenced Collections (Java 21)"/><published>2023-10-17T21:45:00-06:00</published><updated>2023-10-17T21:45:00-06:00</updated><id>https://thoughtstopen.com/java-21-sequenced-collections</id><content type="html" xml:base="https://thoughtstopen.com/java-21-sequenced-collections/"><![CDATA[<h1 id="sequenced-collection">Sequenced Collection</h1><p>Its a great addition to the existing Collection framework which allows access to the first and last elements of a collection out-of-the-box (using its default methods). Apart from this, it also allow us to get the reversed view of our Collection.</p><p>Sequenced Collections are part of <a href="https://openjdk.org/jeps/431" target="_blank">JPE-431</a>.</p><p>Sequenced Collection introduced 3 new interfaces in the Collection framework hierarchy.</p><ol><li>SequencedCollection</li><li>SequencedSet</li><li>SequencedMap</li></ol><p><img src="https://cr.openjdk.org/~smarks/collections/SequencedCollectionDiagram20220216.png" alt="Image shows new Collection interfaces introduced in the java Collection framework." title="Hierarchy of New Interfaces introduced in Java 21 Collection Framework"/></p><p>Lets discuss more about them in details.</p><ol><li><h3 id="sequencedcollection-interface">SequencedCollection Interface</h3><p>The <strong>SequencedCollection</strong> interface introduced methods to add, get, and remove elements from the ends of the collection. It also provides a <em>reversed()</em> method which provides a reverse order view of the collection object.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SequencedCollection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
   	<span class="nc">SequencedCollection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">reversed</span><span class="o">();</span>
	  	
   	<span class="k">default</span> <span class="kt">void</span> <span class="nf">addFirst</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span>
	  	
   	<span class="k">default</span> <span class="kt">void</span> <span class="nf">addLast</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span>
	  	
   	<span class="k">default</span> <span class="no">E</span> <span class="nf">getFirst</span><span class="o">()</span>
	  	
   	<span class="k">default</span> <span class="no">E</span> <span class="nf">getLast</span><span class="o">()</span>
	  	
   	<span class="k">default</span> <span class="no">E</span> <span class="nf">removeFirst</span><span class="o">()</span>
	  	
   	<span class="k">default</span> <span class="no">E</span> <span class="nf">removeLast</span><span class="o">()</span>
    <span class="o">}</span>
</code></pre></div></div><p>Except for reversed(), all are default operations. For Example:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
   <span class="n">integerList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span> <span class="c1">//[100]</span>
	
   <span class="n">integerList</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span> <span class="c1">//[50,100]</span>
   <span class="n">integerList</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="mi">150</span><span class="o">);</span> <span class="c1">//[50,100,150]</span>
		
   <span class="n">integerList</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span> <span class="c1">//50</span>
   <span class="n">integerList</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span> <span class="c1">//150</span>
		
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">integerList</span><span class="o">.</span><span class="na">reversed</span><span class="o">());</span> <span class="c1">//[150,100,50]</span>
	  
   <span class="c1">//integerList = [50,100,150]</span>
   <span class="n">integerList</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span> <span class="c1">//[100,150]</span>
   <span class="n">integerList</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span> <span class="c1">//[100]</span>
</code></pre></div></div></li><li><h3 id="sequencedset-interface">SequencedSet Interface</h3><p>SequencedSet interface extends SequencedCollection and is specific to the <em>Set</em> implementation. It overrides the <em>reverse()</em> method and returns a SequencedSet<E>.</E></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SequencedSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">SequencedCollection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
     <span class="nc">SequencedSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">reversed</span><span class="o">();</span>
 <span class="o">}</span>
</code></pre></div></div><p>Lets look into an example.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SequencedSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;();</span>
 <span class="n">integerSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span> 	<span class="c1">//[100]</span>
	
 <span class="n">integerSet</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span> <span class="c1">//[50,100]</span>
 <span class="n">integerSet</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="mi">150</span><span class="o">);</span> <span class="c1">//[50,100,150]</span>
		
 <span class="n">integerSet</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span> <span class="c1">//50</span>
 <span class="n">integerSet</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span> <span class="c1">//150</span>
			
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">integerSet</span><span class="o">.</span><span class="na">reversed</span><span class="o">());</span> <span class="c1">//[150,100,50]</span>
</code></pre></div></div></li><li><h3 id="sequencedmap-interface">SequencedMap Interface</h3><p>It applies to the Map classes and as shown in the diagram above, it doesn’t extend the <code class="language-plaintext highlighter-rouge">SequencedCollection</code> interface but rather it provide its own methods for access order.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SequencedMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
     <span class="nc">SequencedMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">reversed</span><span class="o">();</span>
		
     <span class="k">default</span> <span class="no">V</span> <span class="nf">putFirst</span><span class="o">(</span><span class="no">K</span> <span class="n">k</span><span class="o">,</span> <span class="no">V</span> <span class="n">v</span><span class="o">)</span> <span class="o">{}</span>
     <span class="k">default</span> <span class="no">V</span> <span class="nf">putLast</span><span class="o">(</span><span class="no">K</span> <span class="n">k</span><span class="o">,</span> <span class="no">V</span> <span class="n">v</span><span class="o">)</span> <span class="o">{}</span>
		
     <span class="k">default</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">firstEntry</span><span class="o">(){}</span>
     <span class="k">default</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">lastEntry</span><span class="o">()</span> <span class="o">{}</span>
     <span class="k">default</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">pollFirstEntry</span><span class="o">()</span> <span class="o">{}</span>
     <span class="k">default</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">pollLastEntry</span><span class="o">()</span> <span class="o">{}</span>
		
     <span class="k">default</span> <span class="nc">SequencedSet</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="nf">sequencedKeySet</span><span class="o">()</span> <span class="o">{}</span>
     <span class="k">default</span> <span class="nc">SequencedCollection</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">sequencedValues</span><span class="o">()</span> <span class="o">{}</span>
     <span class="k">default</span> <span class="nc">SequencedSet</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;&gt;</span> <span class="nf">sequencedEntrySet</span><span class="o">()</span> <span class="o">{}</span>
		
 <span class="o">}</span>
</code></pre></div></div><p>Lets again look at its example</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SequencedMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">daysOfWeekMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
		
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">"MONDAY"</span><span class="o">);</span>
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">"TUESDAY"</span><span class="o">);</span>
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="s">"WEDNESDAY"</span><span class="o">);</span>
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="s">"THURSDAY"</span><span class="o">);</span>
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="s">"FRIDAY"</span><span class="o">);</span>
 <span class="c1">//{2=MONDAY, 3=TUESDAY, 4=WEDNESDAY, 5=THURSDAY, 6=FRIDAY}</span>
	
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">putFirst</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"SUNDAY"</span><span class="o">);</span>
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">putLast</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="s">"SATURDAY"</span><span class="o">);</span>
 <span class="c1">//{1=SUNDAY, 2=MONDAY, 3=TUESDAY, 4=WEDNESDAY, 5=THURSDAY, 6=FRIDAY, 7=SATURDAY}</span>
	
	
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">firstEntry</span><span class="o">();</span>	<span class="c1">//1=SUNDAY</span>
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">lastEntry</span><span class="o">();</span>	<span class="c1">//7=SATURDAY</span>
	
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">sequencedKeySet</span><span class="o">();</span>	<span class="c1">//[1, 2, 3, 4, 5, 6, 7]</span>
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">sequencedValues</span><span class="o">();</span>	<span class="c1">//[SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY]</span>
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">sequencedEntrySet</span><span class="o">();</span>	<span class="c1">//[1=SUNDAY, 2=MONDAY, 3=TUESDAY, 4=WEDNESDAY, 5=THURSDAY, 6=FRIDAY, 7=SATURDAY]</span>
	
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">pollFirstEntry</span><span class="o">();</span>
 <span class="n">daysOfWeekMap</span><span class="o">.</span><span class="na">pollLastEntry</span><span class="o">();</span>
 <span class="c1">//{2=MONDAY, 3=TUESDAY, 4=WEDNESDAY, 5=THURSDAY, 6=FRIDAY}</span>
	
</code></pre></div></div></li><li><h3 id="addition-to-collections-class">Addition to Collections Class</h3><p>In order to accommodate these new data types, new methods has been added to <code class="language-plaintext highlighter-rouge">Collections</code> class.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Collections</span><span class="o">.</span><span class="na">unmodifiableSequencedCollection</span><span class="o">(</span><span class="n">sequencedCollection</span><span class="o">);</span>
 <span class="nc">Collections</span><span class="o">.</span><span class="na">unmodifiableSequencedSet</span><span class="o">(</span><span class="n">sequencedSet</span><span class="o">);</span>
 <span class="nc">Collections</span><span class="o">.</span><span class="na">unmodifiableSequencedMap</span><span class="o">(</span><span class="n">sequencedMap</span><span class="o">);</span>
</code></pre></div></div></li><li><h3 id="common-exceptions">Common Exceptions</h3><p>If we try to perform these operations on a immmutable data type or a collection which already have a specific order, an <code class="language-plaintext highlighter-rouge">UnsupportedOperationException</code> is thrown</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SequencedCollection</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">immutableList</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">);</span>
 <span class="n">immutableList</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
	
 <span class="nc">SequencedMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">treeMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;(</span><span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">200</span><span class="o">));</span>
 <span class="n">treeMap</span><span class="o">.</span><span class="na">putLast</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">300</span><span class="o">);</span>
	
 <span class="cm">/*
 Exception in thread "main" java.lang.UnsupportedOperationException
 at java.base/java.util.ImmutableCollections.uoe(ImmutableCollections.java:142)
 at java.base/java.util.ImmutableCollections$AbstractImmutableList.add(ImmutableCollections.java:258)
 at java.base/java.util.List.addFirst(List.java:796)
 */</span>
</code></pre></div></div><p>Similarly, when trying to fetch first or last elements from an empty collection results in <code class="language-plaintext highlighter-rouge">NoSuchElementException</code></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SequencedSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">treeMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;(</span><span class="nc">Set</span><span class="o">.</span><span class="na">of</span><span class="o">());</span>
 <span class="n">treeMap</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
 <span class="cm">/*
 Exception in thread "main" java.util.NoSuchElementException
 at java.base/java.util.TreeMap.key(TreeMap.java:1637)
 at java.base/java.util.TreeMap.lastKey(TreeMap.java:309)
 at java.base/java.util.TreeSet.last(TreeSet.java:402)
 at java.base/java.util.SortedSet.getLast(SortedSet.java:320)
 */</span>
</code></pre></div></div></li></ol>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[Sequenced Collections introduced in Java 21]]></summary></entry><entry><title type="html">Virtual Threads (Java 21)</title><link href="https://thoughtstopen.com/java-21-virtual-threads/" rel="alternate" type="text/html" title="Virtual Threads (Java 21)"/><published>2023-10-12T21:55:00-06:00</published><updated>2023-10-12T21:55:00-06:00</updated><id>https://thoughtstopen.com/java-21-virtual-threads</id><content type="html" xml:base="https://thoughtstopen.com/java-21-virtual-threads/"><![CDATA[<h1 id="virtual-threads">Virtual Threads</h1><p><strong>NOTE</strong>: This is a preview feature <em>NOT</em> enabled by-default in JDK-21.</p><p>Virtual Threads are introduced under <strong>Project Loom</strong> and are part of <a href="https://openjdk.org/jeps/436" target="_blank">JPE-436</a>.</p><p>We all might have heard about Threads in Java. They are old, very old, since JDK 2 released in 1998. 🕰</p><p>They did a very good job in concurrent processing. But we must admit, in this ever changing world of programming, they have few problems:</p><ol><li>Even though they were light weight processes, but the Threads were just a thin wrapper around the operating system threads (the OS Threads). It was costly to create them and having a number of Threads running concurrently was practically limited by the system’s hardware, since <strong>they are mapped 1:1 to the OS threads</strong>.</li><li>With the advancements in the J2EE, every incoming request is handled by a thread (<em>thread-per-request</em> pattern). In the today’s world of microservices, a single request can fetch or update data on multiple systems. When the application waits for the response from other microservices, the current thread remains in the idle state.</li><li>Also, with the advent of Reactive Programming, much of the request-response have gone asynchronous. Information is request by a separate thread and the response is accepted on a separate thread, it makes it very difficult to debug. 😮‍💨</li></ol><h3 id="virtual-threads-1">Virtual Threads</h3><p>Virtual Threads are also instances of <em>java.lang.Thread</em>. They run their code on the underlying OS thread, but <strong>DON’T block the OS thread for its entire execution</strong>. Multiple virtual threads can be associated to a single OS thread.</p><p><img src="/assets/img/VirtualThreads.png" alt="Virtual Thread's hierarchical diagram " title="Hierarchy Diagram for Virtual Threads"/></p><p>We can create millions ($ 10^ 6 $) of virtual threads independent of our system hardware. Virtual Threads are managed by JVM, so the overhead of context-switching is avoided.</p><p>Virtual Threads do not block OS threads while they are not running. They are best suited for asynchronous APIs for achieving high scalability and throughput.</p><h2 id="differences-between-classic-threads-and-virtual-threads">Differences between Classic Threads and Virtual Threads</h2><ul><li><strong>Virtual Threads are daemon threads</strong>: Means JVM won’t wait for them to be completed when exiting.</li><li><strong>Virtual Threads always have normal priority</strong>.</li><li><strong>Virtual Threads are not active members of thread group.</strong>: Call to <em>Thread.getThreadGroup()</em> on a virtual thread gives a generic name “<em>VirtualThreads</em>”.</li><li><strong>Virtual Threads do not support <em>stop()</em>, <em>resume()</em> or <em>suspend()</em> methods</strong>.</li></ul><h2 id="execution-and-performance-comparison-of-classic-threads-and-virtual-threads">Execution and Performance Comparison of Classic Threads and Virtual Threads</h2><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.atomic.AtomicInteger</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.IntStream</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">VirtualThreads</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
		<span class="kd">final</span> <span class="nc">AtomicInteger</span> <span class="n">increment</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">();</span>
		<span class="nc">Runnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
			<span class="k">try</span> <span class="o">{</span>
				<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
			<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">};</span>

		<span class="c1">// Classic Threads</span>
		<span class="kt">long</span> <span class="n">startTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
		<span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">100</span><span class="o">))</span> <span class="o">{</span>
			<span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">10_000</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">runnable</span><span class="o">));</span>
		<span class="o">}</span>
		<span class="kt">long</span> <span class="n">endTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>

		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Classic Threads Total Time Taken: %d milliseconds"</span><span class="o">,</span> <span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="o">));</span>

		<span class="c1">// Virtual Threads</span>
		<span class="n">startTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
		<span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newVirtualThreadPerTaskExecutor</span><span class="o">())</span> <span class="o">{</span>
			<span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">10_000</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">runnable</span><span class="o">));</span>
		<span class="o">}</span>
		<span class="n">endTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>

		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Virtual Threads Total Time Taken: %d milliseconds"</span><span class="o">,</span> <span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="o">));</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div><p>Since its a preview feature, similar to <a href="/java-21-String-Templates/">String Templates</a>, they are NOT enabled by default. Run the above code as:</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">--enable-preview</span> <span class="nt">--source</span> 21 VirtualThreads.java
</code></pre></div></div><p>Output is:</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Classic Threads Total Time Taken: 100798 milliseconds
Virtual Threads Total Time Taken: 1823 milliseconds
</code></pre></div></div><p>This huge difference in the execution time is due to the fact that the Executor service have created around 10K Virtual Threads since they are very light weight and doesn’t require overhead of context switching as Classic threads do.</p><p>I tried experimenting with the fixed pool size of Classic threads. Even when I increased its size to 10K via <code class="language-plaintext highlighter-rouge">Executors.newFixedThreadPool(10000)</code>, I still got better performance for Virtual Threads (~3x more faster).</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Classic Threads Total Time Taken: 3569 milliseconds
Virtual Threads Total Time Taken: 1366 milliseconds
</code></pre></div></div>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[Virtual Threads NOTE: This is a preview feature NOT enabled by-default in JDK-21.]]></summary></entry><entry><title type="html">String Templates (Java 21)</title><link href="https://thoughtstopen.com/java-21-String-Templates/" rel="alternate" type="text/html" title="String Templates (Java 21)"/><published>2023-10-12T21:41:00-06:00</published><updated>2023-10-12T21:41:00-06:00</updated><id>https://thoughtstopen.com/java-21-String-Templates</id><content type="html" xml:base="https://thoughtstopen.com/java-21-String-Templates/"><![CDATA[<h1 id="string-templates">String Templates</h1><p><strong>NOTE</strong>: This is a preview feature <em>NOT</em> enabled by-default in JDK-21.</p><p>String Templates are introduced as per java specification <a href="https://openjdk.org/jeps/430" title="JEP 430: String Templates (Preview)" target="_blank">JPE-430</a>.</p><p>They provide a way to introduce variables into strings which are resolved during runtime.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringTemplate</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"T2P"</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Greetings from \{name}!"</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>	<span class="c1">//Expected Output: Greetings from T2P!</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Lets say we run this program via command prompt</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java StringTemplate.java
</code></pre></div></div><p>This code will not compile and we’ll get below errors</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>StringTemplate.java:4: error: string templates are a preview feature and are disabled by default.
        private static String message <span class="o">=</span> STR.<span class="s2">"Greetings from </span><span class="se">\{</span><span class="s2">name}!"</span><span class="p">;</span>
                                            ^
  <span class="o">(</span>use <span class="nt">--enable-preview</span> to <span class="nb">enable </span>string templates<span class="o">)</span>
1 error
error: compilation failed
</code></pre></div></div><p>So in order to resolve it, we need to enable the preview feature using <code class="language-plaintext highlighter-rouge">--enable-preview</code> for jdk 21 using <code class="language-plaintext highlighter-rouge">--source 21</code></p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">--enable-preview</span> <span class="nt">--source</span> 21 StringTemplate.java
</code></pre></div></div><p>Now we can see the program compiles correctly and produces the below output</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Note: StringTemplate.java uses preview features of Java SE 21.
Note: Recompile with <span class="nt">-Xlint</span>:preview <span class="k">for </span>details.
Greetings from T2P!
</code></pre></div></div><p>Finally we got our code running 🤩.</p><p>Few more points on <em>String Templates</em></p><ol><li><code class="language-plaintext highlighter-rouge">STR</code> template processor is the part of the language and is automatically included in every class.</li><li>Not only local variables but methods and instance variables are also supported. <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Greetings from \{name}!"</span><span class="o">;</span>        <span class="c1">//local variable</span>
  <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Greetings from \{getName()}!"</span><span class="o">;</span>   <span class="c1">//method</span>
  <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Greetings from \{this.name}!"</span><span class="o">;</span>   <span class="c1">//instance variable</span>
</code></pre></div></div></li><li>Mathematical Expressions too. <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">30</span><span class="o">;</span>
  <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"\{a+b}"</span><span class="o">;</span>	<span class="c1">//40</span>
</code></pre></div></div></li><li>Double quotes need not to be escaped in String Templates <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">boolean</span> <span class="n">test</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="nc">String</span> <span class="n">msg</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"The result is \{ test? "</span><span class="kc">true</span><span class="s">" : "</span><span class="kc">false</span><span class="s">" }."</span><span class="o">;</span>	<span class="c1">//The result is true.</span>
</code></pre></div></div></li><li>Multi-line expressions are allowed too. <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kn">import</span> <span class="nn">java.time.LocalDateTime</span><span class="o">;</span>
  <span class="nc">String</span> <span class="n">currentDateTime</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Current Date and Time is: \{
  LocalDateTime.now()
  }"</span><span class="o">;</span>
  <span class="c1">//Current Date and Time is: 2023-10-07T08:55:36.874386100</span>
</code></pre></div></div></li></ol>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[String Templates introduced in Java 21]]></summary></entry><entry><title type="html">Java 21 Features</title><link href="https://thoughtstopen.com/java-21-features/" rel="alternate" type="text/html" title="Java 21 Features"/><published>2023-10-07T20:11:00-06:00</published><updated>2023-10-07T20:11:00-06:00</updated><id>https://thoughtstopen.com/java-21-features</id><content type="html" xml:base="https://thoughtstopen.com/java-21-features/"><![CDATA[<ul><li><h2 id="string-templates-preview-feature"><a href="/java-21-String-Templates/">String Templates (Preview Feature)</a></h2><p>String Templates allow us to embed expressions (variables, methods or fields) into Strings, which are evaluated at runtime.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"T2P"</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Greetings from \{name}!"</span><span class="o">;</span>	<span class="c1">//Greetings from T2P!</span>
</code></pre></div></div></li><li><h2 id="virtual-threads"><a href="/java-21-virtual-threads/">Virtual Threads</a></h2><p>Virtual Threads are JVM managed lightweight threads. Lighter than the traditional Threads.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Executors</span><span class="o">.</span><span class="na">newVirtualThreadPerTaskExecutor</span><span class="o">();</span>
</code></pre></div></div></li><li><h2 id="sequenced-collections"><a href="/java-21-sequenced-collections/">Sequenced Collections</a></h2><p>New interface <strong>Sequenced Collection</strong> is introduced in the Collections framework which provides new functionality of <em>defined encounter order</em>, which means, we will have a well-defined order for first element, second element, upto the last element.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="n">integerList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span> <span class="c1">//[100]</span>
	
  <span class="n">integerList</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span> <span class="c1">//[50,100]</span>
  <span class="n">integerList</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="mi">150</span><span class="o">);</span> <span class="c1">//[50,100,150]</span>
	
  <span class="n">integerList</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span> <span class="c1">//50</span>
  <span class="n">integerList</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span> <span class="c1">//150</span>
</code></pre></div></div></li><li><h2 id="record-patterns"><a href="/java-21-record-patterns/">Record Patterns</a></h2><p><strong>Record Patterns</strong> allow you to deconstruct (unpack) record values directly in pattern matching. This eliminates the need for casting and calling accessor methods, making code more concise and readable.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">record</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{}</span>
    
  <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">))</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div></div></li><li><h2 id="pattern-matching-for-switch"><a href="/java-21-pattern-matching-switch/">Pattern Matching for switch</a></h2><p>This feature enhances the <code class="language-plaintext highlighter-rouge">switch</code> statement to support <strong>patterns</strong> in case labels. It allows testing against types (replacing <code class="language-plaintext highlighter-rouge">if-else</code> chains), handling <code class="language-plaintext highlighter-rouge">null</code> correctly, and using guards (<code class="language-plaintext highlighter-rouge">when</code>) for refined matching.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">return</span> <span class="k">switch</span> <span class="o">(</span><span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Integer</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"int %d"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
      <span class="k">case</span> <span class="nc">String</span> <span class="n">s</span>  <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"String %s"</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
      <span class="k">default</span>        <span class="o">-&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
  <span class="o">};</span>
</code></pre></div></div></li><li><h2 id="unnamed-classes-and-instance-main-methods-preview"><a href="/java-21-unnamed-classes/">Unnamed Classes and Instance Main Methods (Preview)</a></h2><p>Designed properly for beginners, this feature reduces the “Hello World” boilerplate. You can write programs without explicitly declaring a <code class="language-plaintext highlighter-rouge">class</code>, <code class="language-plaintext highlighter-rouge">detailed main method signature</code>, or <code class="language-plaintext highlighter-rouge">access modifiers</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div></div></li><li><h2 id="structured-concurrency-preview"><a href="/java-21-structured-concurrency/">Structured Concurrency (Preview)</a></h2><p>If you use Virtual Threads, this feature is for you. It simplifies concurrent code by treating groups of related tasks as a single unit. If one sub-task fails, the others are automatically cleaned up, preventing resource leaks and making error handling robust.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StructuredTaskScope</span><span class="o">.</span><span class="na">ShutdownOnFailure</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">findUser</span><span class="o">());</span>
      <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">fetchOrders</span><span class="o">());</span>
      <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span> 
      <span class="c1">// ...</span>
  <span class="o">}</span>
</code></pre></div></div></li><li><h2 id="unnamed-patterns-and-variables-preview"><a href="/java-21-unnamed-patterns/">Unnamed Patterns and Variables (Preview)</a></h2><p>Allows you to use the underscore <code class="language-plaintext highlighter-rouge">_</code> to denote unused variables or record components. This removes clutter from your code and makes your intent clear (“I am intentionally ignoring this value”).</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">))</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"X is "</span> <span class="o">+</span> <span class="n">x</span><span class="o">);</span>
  <span class="o">}</span>
    
  <span class="k">try</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div></li></ul>]]></content><author><name></name></author><category term="programming"/><category term="java"/><category term="java21"/><summary type="html"><![CDATA[All new features introduced in Java 21]]></summary></entry><entry><title type="html">U$A ਕੈਫੇਟੇਰੀਆ</title><link href="https://thoughtstopen.com/usa-cafeteria/" rel="alternate" type="text/html" title="U$A ਕੈਫੇਟੇਰੀਆ"/><published>2023-02-22T20:40:00-07:00</published><updated>2023-02-22T20:40:00-07:00</updated><id>https://thoughtstopen.com/usa-cafeteria</id><content type="html" xml:base="https://thoughtstopen.com/usa-cafeteria/"><![CDATA[<p>ਅੰਬਰ ਨੂੰ ਕਈ ਵਰ੍ਹੇ ਹੋ ਗਏ ਸਨ ਮਜ਼ਦੂਰੀ ਕਰਦੇ ਪਰ ਉਸਦੀ ਕਮਾਈ ਨਾਲ਼ ਨਾ ਤਾਂ ਜੂਨ ਗੁਜ਼ਾਰਾ ਚੱਲਦਾ ਸੀ ਤੇ ਨਾ ਹੀ ਉਸ ਦੀ ਆਤਮਾ ਨੂੰ ਤ੍ਰਿਪਤੀ ਮਿਲਦੀ ਸੀ। ਉਸ ਦੇ ਹਾਲਾਤ ਮਾੜੇ ਸਨ ਕਿਉਂਕਿ ਉਹ ਗਰੀਬ ਤੇ ਅਲਪ ਸਿੱਖਿਅਤ ਸੀ। ਉਹ ਬੜੀ ਵਿਲੱਖਣ ਸੋਚ ਵਾਲ਼ਾ ਇਨਸਾਨ ਸੀ। ਸਭਤੋਂ ਅਲੱਗ ਸੋਚਣ ਦੀ ਉਸਦੀ ਆਦਤ ਉਸਨੂੰ ਦੂਜਿਆਂ ਤੋਂ ਵੱਖ ਕਰਦੀ ਸੀ। ਉਸਦੇ ਆਲ਼ੇ ਦੁਆਲ਼ੇ ਦੇ ਲੋਕ ਤੇ ਸਾਕ ਸਬੰਧੀ ਉਸਨੂੰ ਛੋਟੀ ਸੋਚ ਵਾਲ਼ਾ ਆਖ਼ਦੇ ਸਨ। ਉਮਰ ਦੇ ਤਿੰਨ ਦਹਾਕਿਆਂ ਤੋਂ ਵੱਧ ਸਮੇਂ ਵਿੱਚ ਉਸਨੇ ਜ਼ਿੰਦਗੀ ਦੇ ਕਈ ਉਤਾਰ ਚੜ੍ਹਾਅ ਵੇਖੇ ਸਨ। ਹਰ ਥਾਂ ਤੋਂ ਅਸਫ਼ਲਤਾ, ਧੋਖੇ ਤੇ ਨਾਕਾਮੀਆਂ ਉਸ ਦੇ ਪੱਲੇ ਆਈਆਂ ਸਨ। ਉਮਰ ਤੋਂ ਕਿਤੇ ਪਹਿਲਾਂ ਹੀ ਉਹ ਬੁੱਢਾ ਦਿਸਣ ਲੱਗ ਪਿਆ ਸੀ। ਉਹ ਕਦੇ ਕਦੇ ਖੁਦਕੁਸ਼ੀ ਕਰਨ ਬਾਰੇ ਸੋਚਦਾ ਪਰ ਮੌਤ ਵੀ ਉਹਨੂੰ ਧੋਖਾ ਨਾ ਦੇ ਜਾਵੇ ਇਹ ਖ਼ਿਆਲ ਕਰ ਕੇ ਉਹ ਰੁਕ ਜਾਂਦਾ। ਉਹ ਰੋ ਵੀ ਨਹੀਂ ਸੀ ਸਕਦਾ ਕਿਉਂਕਿ ਦੁੱਖਾਂ ਦੀਆਂ ਹਨੇਰੀਆਂ ਨੇ ਉਸ ਦੀਆਂ ਅੱਖਾਂ ਦੇ ਸਮੁੰਦਰ ਵੀ ਸੁਕਾ ਦਿੱਤੇ ਸਨ। ਇੱਕ ਖਾਲੀਪਣ ਉਸ ਦੀ ਜ਼ਿੰਦਗੀ ਵਿੱਚ ਪਸਰ ਗਿਆ ਸੀ। ਜੋ ਉਸ ਉੱਤੇ ਬੀਤ ਰਹੀ ਸੀ, ਉਹ ਉਹ ਹੀ ਜਾਣਦਾ ਸੀ। ਇੱਕ ਦਿਨ ਉਸ ਦਾ ਇੱਕ ਰਿਸ਼ਤੇਦਾਰ ਅਨਮੋਲ ਉਸ ਨੂੰ ਮਿਲਣ ਆਇਆ। ਅਨਮੋਲ ਜਾਰਜੀਆ ਵਿੱਚ ਪਰਮਾਨੈਂਟ ਰੇਜੀਡੇਂਟ(PR) ਸੀ। ਉਸ ਦੀ ਫੈਮਿਲੀ ਵੀ ਉੱਥੇ ਹੀ ਸੈਟਲ ਸੀ। ਚਾਹ ਪਾਣੀ ਮਗਰੋਂ ਘੰਟਾ ਭਰ ਗੱਲਾਂ ਹੁੰਦੀਆਂ ਰਹੀਆਂ। ਫਿਰ ਅੰਬਰ ਕਿਸੇ ਕੰਮ ਕਮਰੇ ਤੋਂ ਬਾਹਰ ਚਲਾ ਗਿਆ। ਅਨਮੋਲ ਦੀ ਨਜ਼ਰ ਉਸ ਦੀ ਟੇਬਲ ‘ਤੇ ਇੱਕ ਨੋਟਬੁੱਕ ‘ਤੇ ਪਈ। ਉਸ ਵਿੱਚ ਲਿਖਿਆ ਹੋਇਆ ਸੀ <em>U$A Cafeteria</em>। ਅਨਮੋਲ ਨੇ ਪੰਨਾ ਪਲਟਿਆ ਤਾਂ ਇੱਕ ਵਿੰਗੀ ਟੇਢੀ ਜਿਹੀ ਆਕ੍ਰਿਤੀ ਬਣੀ ਹੋਈ ਸੀ। ਅਗਲੇ ਪੰਨੇ ‘ਤੇ ਇੱਕ ਆਰਟੀਕਲ ਲਿਖਿਆ ਹੋਇਆ ਸੀ,ਜੋ ਕੁੱਝ ਇਸ ਤਰ੍ਹਾਂ ਸੀ :-</p><p>A cafeteria in USA started by Ashnoor along with his spouse Uliya and cousin brother Kapil. Ashnoor was handling management and cash counter while Uliya was the chef. Kapil was working as a waiter, cleaning tables, taking customer orders, serving food. Later on the cafeteria which was serving tea and coffee was turned into a mini tuck shop due to the efforts of trio where they firstly stated serving Aaloo ka parantha with curd &amp; whey, the traditional Punjabi recipe. There were a lot of Indian people living solemnly &amp; with families who weren’t having enough time to cook the various recipe due to lack of time. As it was a business class area so most people were working for their livings &amp; busy in earning. This cafeteria become famous in town &amp; then soon Ashnoor decided to turn it in a restaurant. But this wasn’t the because of investment &amp; hardwork of Ashnoor &amp; Uliya but also the efforts of Kapil. He had suggested Ashnoor to open the cafeteria. Uliya named it USA cafeteria but Kapil insisted to change the same as U$A cafeteria. To turn it into mini hotel and then restaurant was the discussion of trio. Their business was growing up sufficiently but they were a bit tired sometimes with preparations. The popularity of their cafeteria wasn’t growing in start but Kapil advised Ashnoor to promote the cafeteria on social media aka Instagram Facebook &amp; YouTube. This job was very well done by Ashnoor and even customer supported them because they were getting good services. Many customers and bypassers were amazed by unique name of cafeteria <strong>U$A</strong> instead of USA. This was the very first idea of Kapil before starting this small business.</p><p>U=Uliya</p><p>$=source of income and happiness</p><p>A=Ashnoor</p><p>But do you know who are those trio ?</p><p>ਅਗਲੇ ਪੰਨੇ ਖ਼ਾਲੀ ਸਨ। ਖੌਰੇ ਕਹਾਣੀ ਮੁੱਕ ਗਈ ਸੀ ਜਾਂ ਅੰਬਰ ਨੇ ਇਸ ਨੂੰ ਵਿਰਾਮ ਦੇ ਦਿੱਤਾ ਸੀ। ਕੁੱਝ ਸਮੇਂ ਲਈ ਅਨਮੋਲ ਸੋਚੀਂ ਪੈ ਗਿਆ। ਆਖ਼ਿਰ ਕੌਣ ਸਨ ਇਹ ਅਸ਼ਨੂਰ,ਯੂਲੀਆ ਤੇ ਕਪਿਲ ? ਥੋੜਾ ਦਿਮਾਗ ‘ਤੇ ਜ਼ੋਰ ਦੇਣ ਮਗਰੋਂ ਅਨਮੋਲ ਨੂੰ ਸਾਰੀ ਕਹਾਣੀ ਸਮਝ ਆ ਗਈ। ਅਚਾਨਕ ਕੁੱਝ ਡਿੱਗਣ ਦੀ ਆਵਾਜ਼ ਆਈ। ਬੂਹੇ ਵਿੱਚ ਅੰਬਰ ਖੜ੍ਹਾ ਸੀ। ਉਸ ਨੇ ਅਨਮੋਲ ਨੂੰ ਪੁੱਛਿਆ,”ਕੀ ਹੋਇਆ?” “ਜਾਹ ਯਾਰ, ਰਿਹਾ ਨਾ ਤੂੰ ਉਹੀ ਛੋਟੀ ਸੋਚ ਵਾਲ਼ਾ!” ਕਹਿਕੇ ਅਨਮੋਲ ਆਪਣੀ ਗੱਡੀ ਵਿੱਚ ਬੈਠ ਕੇ ਚਲਾ ਗਿਆ।</p><p>“ਆਹ ਰਿਸ਼ਤਾ ਵੀ ਤਿੜਕ ਗਿਆ।” ਹਾਉਕਾ ਲੈਂਦੇ ਅੰਬਰ ਦੇ ਮੂੰਹੋਂ ਆਪ ਮੁਹਾਰੇ ਨਿਕਲ ਪਿਆ।</p>]]></content><author><name>Armaan</name></author><category term="literature"/><category term="punjabi"/><summary type="html"><![CDATA[ਅਧੂਰੀ ਕਹਾਣੀ।]]></summary></entry></feed>